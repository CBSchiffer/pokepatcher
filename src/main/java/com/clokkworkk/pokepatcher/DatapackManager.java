package com.clokkworkk.pokepatcher;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import io.netty.buffer.ByteBuf;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;

public class DatapackManager {

    private static final Path DATAPACK_PATH = Paths.get("config", "pokepatcher", "datapacks");
    private static final Path OUTPUT_PATH = Paths.get( "config", "pokepatcher", "generated");

    public static void packageDatapacks() {
        try {
            PokePatcher.LOGGER.info("Scanning for datapacks...");
            Files.createDirectories(DATAPACK_PATH);
            Files.createDirectory(OUTPUT_PATH);
            Files.list(DATAPACK_PATH)
                    .filter(Files::isDirectory)
                    .forEach(DatapackManager::packageDatapack);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void packageDatapack(Path datapackPath) {
        String modId = datapackPath.getFileName().toString().toLowerCase().replaceAll("[^a-z0-9_]", "_");
        String description = "Auto-generated datapack for " + modId;
        Path meta = datapackPath.resolve("pack.mcmeta");

        if (Files.exists(meta)) {
            try (BufferedReader reader = Files.newBufferedReader(meta)) {
                JsonObject json = JsonParser.parseReader(reader).getAsJsonObject();
                if (json.has("pack")) {
                    JsonObject pack = json.getAsJsonObject("pack");
                    if (pack.has("description")) {
                        description = escapeJson(pack.get("description").getAsString());
                    }
                }
            } catch (Exception e) {
                PokePatcher.LOGGER.error("Failed to parse pack.mcmeta for " + datapackPath);
                e.printStackTrace();
            }
        }


        Path outputJar = OUTPUT_PATH.resolve(modId + ".jar");
        try (JarOutputStream jos = new JarOutputStream(Files.newOutputStream(outputJar))) {
            jos.putNextEntry(new JarEntry("fabric.mod.json"));
            jos.write(generateFabricModJson(modId, modId + "-patched", description).getBytes());
            jos.closeEntry();

            copyDirectoryToJar(datapackPath.resolve("data"), "data/", jos);
            copyDirectoryToJar(datapackPath.resolve("assets"), "assets/", jos);

            PokePatcher.LOGGER.info("Packaged datapack: " + datapackPath.getFileName());
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private static void copyDirectoryToJar(Path sourceDir, String jarPathPrefix, JarOutputStream jos) throws IOException {
        if(!Files.exists(sourceDir)) {
            return;
        }
        Files.walk(sourceDir).forEach(path -> {
            if (Files.isDirectory(path)) return;
            try {
                String jarEntryName = jarPathPrefix + sourceDir.relativize(path).toString().replace("\\", "/");
                jos.putNextEntry(new JarEntry(jarEntryName));
                Files.copy(path, jos);
                jos.closeEntry();
            } catch (IOException e) {
                e.printStackTrace();
            }
        });
    }

    private static String generateFabricModJson(String modId, String name, String description) {
        return """
                {
                	"schemaVersion": 1,
                	"id": "%s",
                	"version": "1.0.0",
                	"name": "%s",
                	"description": "%s",
                	"authors": [
                		"Auto-Generated by PokePatcher!"
                	],
                	"license": "MIT",
                	"icon": "assets/%s/icon.png",
                	"environment": "*",
                	"entrypoints": {},
                	"depends": {
                		"fabricloader": ">=0.16.14"
                	}
                }
                """.formatted(modId, name, description, modId);
    }

    private static String escapeJson(String str) {
        return str.replace("\"", "\\\"")
                .replace("\n", "\\n");
    }
}
